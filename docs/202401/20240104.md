# 20240104 Thursday

## Leetcode daily

[Minimum Number of Operations to Make Array Empty](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/?envType=daily-question&envId=2024-01-04)

I solved this problem by dynamic programming, but it turns out can be solved by math calculation.
The DP idea is to count the number of appearance times and use the max times as the length to generate the DP array, initialize the index `1` to be infinity, and use the transfer function that `dp[i] = max(dp[i-2], dp[i-3]) + 1`, we use every count value as index get the value in DP array, and sum those value and return it as the answer.

```py
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        counts = defaultdict(int)
        total = 4
        for num in nums:
            counts[num] += 1
            total = max(total, counts[num])

        dp = [1] * (total + 1)
        dp[1] = float('inf')

        for i in range(4, total + 1):
            dp[i] += min(dp[i - 3], dp[i - 2])

        res = 0
        for key in counts:
            cur = counts[key]
            res += dp[cur]
        return res if res != float('inf') else -1
```

The math solution is that every positive integer number can be generated by `2x + 3y` except `1`, to minimize the `x + y`, we use `3` as much as possible, and we divide the value with `3`, the remain value will have three possibles, `0, 1, 2`, for case `0` we can add `val//3` to answer, for case `1,2` means the equation is `2 + 3y` and `4 + 3Y` so both minimal can be represented as `val//3 + 1`, sum all the result of that is the answer.

```py
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        counts = defaultdict(int)
        for num in nums:
            counts[num] += 1
        res = 0
        for key in counts:
            cur = counts[key]
            if cur == 1:
                return -1
            if cur % 3 == 0:
                res += cur//3
            else:
                res += (cur//3) + 1
        return res
```
