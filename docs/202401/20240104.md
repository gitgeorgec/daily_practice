# 20240104 Thursday

## Leetcode daily

[Minimum Number of Operations to Make Array Empty](https://leetcode.com/problems/minimum-number-of-operations-to-make-array-empty/?envType=daily-question&envId=2024-01-04)

I solved this problem by dynamic programming, but it turns out can be solved by math calculation.
The DP idea is to count the number of appearance times and use the max times as the length to generate the DP array, initialize the index `1` to be infinity, and use the transfer function that `dp[i] = max(dp[i-2], dp[i-3]) + 1`, we use every count value as index get the value in DP array, and sum those value and return it as the answer.

```py
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        counts = defaultdict(int)
        total = 4
        for num in nums:
            counts[num] += 1
            total = max(total, counts[num])

        dp = [1] * (total + 1)
        dp[1] = float('inf')

        for i in range(4, total + 1):
            dp[i] += min(dp[i - 3], dp[i - 2])

        res = 0
        for key in counts:
            cur = counts[key]
            res += dp[cur]
        return res if res != float('inf') else -1
```

The math solution is that every positive integer number can be generated by `2x + 3y` except `1`, to minimize the `x + y`, we use `3` as much as possible, and we divide the value with `3`, the remain value will have three possibles, `0, 1, 2`, for case `0` we can add `val//3` to answer, for case `1,2` means the equation is `2 + 3y` and `4 + 3Y` so both minimal can be represented as `val//3 + 1`, sum all the result of that is the answer.

```py
class Solution:
    def minOperations(self, nums: List[int]) -> int:
        counts = defaultdict(int)
        for num in nums:
            counts[num] += 1
        res = 0
        for key in counts:
            cur = counts[key]
            if cur == 1:
                return -1
            if cur % 3 == 0:
                res += cur//3
            else:
                res += (cur//3) + 1
        return res
```

## BFE javascript coding question

[29. implement async helper - `sequence()`](https://bigfrontend.dev/problem/implement-async-helper-sequence)

This is a tricky question, I use two variables, the previous callback and the next callback to record the cb in the iteration, nest the previous to the next callback, make sure to handle error on each callback, and finally call the latest callback when the function calls.

```js
function sequence(funcs) {
  return function (cb, data) {
    let prvCb = cb;
    let nextCb;
    for (const fn of funcs.reverse()) {
      const p = prvCb;
      nextCb = (error, newData) => {
        if (error) {
          cb(error);
        } else {
          fn(p, newData);
        }
      };
      prvCb = nextCb;
    }
    nextCb(null, data);
  };
}

const asyncTimes2 = (callback, num) => {
  setTimeout(() => callback(null, num * 2), 1000);
};
const asyncPlus1 = (callback, num) => {
  setTimeout(() => callback(null, num + 1), 1000);
};
const asyncError = (callback, num) => {
  setTimeout(() => callback(new Error("error")), 1000);
};

const asyncTimesError = sequence([
  asyncPlus1,
  asyncTimes2,
  asyncError,
  asyncTimes2,
  asyncTimes2,
]);
const asyncTimes8plus1 = sequence([
  asyncTimes2,
  asyncTimes2,
  asyncTimes2,
  asyncPlus1,
]);

asyncTimesError((error, data) => {
  if (error) {
    console.log("error.message", error); // error
  } else {
    console.log(data);
  }
}, 1);

asyncTimes8plus1((error, data) => {
  if (error) {
    console.log("error.message", error);
  } else {
    console.log(data); // 9
  }
}, 1);
```

The other solution is use promise.

```js
function sequence(funcs) {
  const promiseFuncs = funcs.map(promisify);

  return function (callback, input) {
    // init promise
    let promise = Promise.resolve(input);

    // add all promiseFuncs to promise
    promiseFuncs.forEach((promiseFunc) => {
      promise = promise.then(promiseFunc);
    });

    // handle resolved or rejected promise
    promise
      .then((data) => {
        callback(undefined, data);
      })
      .catch(callback);
  };
}

function promisify(callback) {
  return function (input) {
    return new Promise((resolve, reject) => {
      callback((err, data) => {
        if (err) {
          reject(err);
          return;
        }

        resolve(data);
      }, input);
    });
  };
}
```
